<!DOCTYPE html>
<html>
<head>
    <title>2D Расстояние от точки до луча</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="info">Расстояние: <span id="distanceValue">0</span></div>
    
    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        
        // Глобальные переменные для управления
        let pointM, pointP1, pointP2;
        let pointMMesh, pointP1Mesh, pointP2Mesh, rayLine, distanceLine, closestPointMesh;
        let isDragging = false;
        let draggedMesh = null;
        
        function createScene() {
            const scene = new BABYLON.Scene(engine);
            
            // Камера для 2D вида
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2, 15, 
                new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);
            camera.inputs.attached.pointers.angularSensibility = 100000;
            
            // Свет
            new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 0, -1), scene);
            
            // Создаем начальные точки
            pointP1 = new BABYLON.Vector3(-3, 0, 0);
            pointP2 = new BABYLON.Vector3(3, 0, 0);
            pointM = new BABYLON.Vector3(1, 2, 0);
            
            // Создаем визуализацию
            createVisualization(scene);
            
            // Настраиваем перетаскивание
            setupDragAndDrop(scene, camera);
            
            return scene;
        }
        
        function createVisualization(scene) {
            // Удаляем старые объекты если есть
            if (rayLine) rayLine.dispose();
            if (distanceLine) distanceLine.dispose();
            if (closestPointMesh) closestPointMesh.dispose();
            
            // Вычисляем расстояние
            const distance = distanceToRay2D(pointM, pointP1, pointP2);
            document.getElementById('distanceValue').textContent = distance.toFixed(2);
            
            // Создаем или обновляем точку M (зеленая)
            if (!pointMMesh) {
                pointMMesh = BABYLON.MeshBuilder.CreateSphere("pointM", { diameter: 0.3 }, scene);
                const greenMat = new BABYLON.StandardMaterial("greenMat", scene);
                greenMat.diffuseColor = new BABYLON.Color3(0, 1, 0);
                pointMMesh.material = greenMat;
            }
            pointMMesh.position = pointM.clone();
            
            // Создаем или обновляем точку P1 (синяя)
            if (!pointP1Mesh) {
                pointP1Mesh = BABYLON.MeshBuilder.CreateSphere("pointP1", { diameter: 0.3 }, scene);
                const blueMat = new BABYLON.StandardMaterial("blueMat", scene);
                blueMat.diffuseColor = new BABYLON.Color3(0, 0, 1);
                pointP1Mesh.material = blueMat;
            }
            pointP1Mesh.position = pointP1.clone();
            
            // Создаем или обновляем точку P2 (синяя)
            if (!pointP2Mesh) {
                pointP2Mesh = BABYLON.MeshBuilder.CreateSphere("pointP2", { diameter: 0.3 }, scene);
                pointP2Mesh.material = pointP1Mesh.material;
            }
            pointP2Mesh.position = pointP2.clone();
            
            // Создаем луч (красная линия от P1 через P2)
            const rayPoints = [
                pointP1,
                pointP2,
                new BABYLON.Vector3(
                    pointP1.x + (pointP2.x - pointP1.x) * 2,
                    pointP1.y + (pointP2.y - pointP1.y) * 2,
                    0
                )
            ];
            rayLine = BABYLON.MeshBuilder.CreateLines("ray", { points: rayPoints }, scene);
            rayLine.color = new BABYLON.Color3(1, 0, 0);
            
            // Вычисляем ближайшую точку на луче
            const closestPoint = findClosestPointOnRay(pointM, pointP1, pointP2);
            
            // Линия расстояния (желтая)
            distanceLine = BABYLON.MeshBuilder.CreateLines("distanceLine", {
                points: [pointM, closestPoint]
            }, scene);
            distanceLine.color = new BABYLON.Color3(1, 1, 0);
            
            // Ближайшая точка (желтая)
            closestPointMesh = BABYLON.MeshBuilder.CreateSphere("closest", { diameter: 0.2 }, scene);
            closestPointMesh.position = closestPoint;
            const yellowMat = new BABYLON.StandardMaterial("yellowMat", scene);
            yellowMat.diffuseColor = new BABYLON.Color3(1, 1, 0);
            closestPointMesh.material = yellowMat;
        }
        
        function setupDragAndDrop(scene, camera) {
            // Настраиваем перетаскивание для точек
            scene.onPointerDown = function(evt, pickResult) {
                if (pickResult.hit) {
                    const mesh = pickResult.pickedMesh;
                    // Проверяем, что кликнули на одну из наших точек
                    if (mesh === pointMMesh || mesh === pointP1Mesh || mesh === pointP2Mesh) {
                        isDragging = true;
                        draggedMesh = mesh;
                    }
                }
            };
            
            scene.onPointerMove = function(evt) {
                if (isDragging && draggedMesh) {
                    // Получаем позицию курсора в мировых координатах
                    const pickResult = scene.pick(scene.pointerX, scene.pointerY);
                    if (pickResult.hit) {
                        const newPosition = pickResult.pickedPoint;
                        
                        // Ограничиваем движение плоскостью Z=0
                        newPosition.z = 0;
                        
                        // Обновляем позицию перетаскиваемой точки
                        if (draggedMesh === pointMMesh) {
                            pointM.copyFrom(newPosition);
                        } else if (draggedMesh === pointP1Mesh) {
                            pointP1.copyFrom(newPosition);
                        } else if (draggedMesh === pointP2Mesh) {
                            pointP2.copyFrom(newPosition);
                        }
                        
                        // Обновляем визуализацию
                        createVisualization(scene);
                    }
                }
            };
            
            scene.onPointerUp = function() {
                isDragging = false;
                draggedMesh = null;
            };
        }
        
        // 2D алгоритм расстояния от точки до луча
        function distanceToRay2D(M, P1, P2) {
            const P1P2_x = P2.x - P1.x;
            const P1P2_y = P2.y - P1.y;
            
            const P1M_x = M.x - P1.x;
            const P1M_y = M.y - P1.y;
            
            const dotProduct = P1M_x * P1P2_x + P1M_y * P1P2_y;
            
            if (dotProduct < 0) {
                return Math.sqrt(P1M_x * P1M_x + P1M_y * P1M_y);
            } else {
                const P1P2_length_sq = P1P2_x * P1P2_x + P1P2_y * P1P2_y;
                const t = dotProduct / P1P2_length_sq;
                
                const proj_x = P1.x + t * P1P2_x;
                const proj_y = P1.y + t * P1P2_y;
                
                const dx = M.x - proj_x;
                const dy = M.y - proj_y;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }
        
        // Находит ближайшую точку на луче
        function findClosestPointOnRay(M, P1, P2) {
            const P1P2_x = P2.x - P1.x;
            const P1P2_y = P2.y - P1.y;
            const P1M_x = M.x - P1.x;
            const P1M_y = M.y - P1.y;
            
            const dotProduct = P1M_x * P1P2_x + P1M_y * P1P2_y;
            
            if (dotProduct < 0) {
                return P1.clone();
            } else {
                const t = dotProduct / (P1P2_x * P1P2_x + P1P2_y * P1P2_y);
                return new BABYLON.Vector3(
                    P1.x + t * P1P2_x,
                    P1.y + t * P1P2_y,
                    0
                );
            }
        }
        
        const scene = createScene();
        
        engine.runRenderLoop(() => {
            scene.render();
        });
        
        window.addEventListener("resize", () => {
            engine.resize();
        });
    </script>
</body>
</html>
