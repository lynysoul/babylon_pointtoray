<!DOCTYPE html>
<html>
<head>
    <title>2D Расстояние от точки до луча</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="info">Расстояние: <span id="distanceValue">0</span></div>
    
    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        
        function createScene() {
            const scene = new BABYLON.Scene(engine);
            
            // Камера для 2D вида (смотрим сверху на плоскость XY)
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2, 15, 
                new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);
            
            // Фиксируем камеру для 2D (опционально)
            camera.inputs.attached.pointers.angularSensibility = 100000;
            
            // Свет
            new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 0, -1), scene);
            
            // Создаем 2D визуализацию
            create2DDistanceVisualization(scene);
            
            return scene;
        }
        
        // 2D версия алгоритма (работает с Vector3 но в плоскости Z=0)
        function distanceToRay2D(M, P1, P2) {
            // Вектор луча P1P2
            const P1P2_x = P2.x - P1.x;
            const P1P2_y = P2.y - P1.y;
            
            // Вектор от P1 до M
            const P1M_x = M.x - P1.x;
            const P1M_y = M.y - P1.y;
            
            // Скалярное произведение (P1M · P1P2)
            const dotProduct = P1M_x * P1P2_x + P1M_y * P1P2_y;
            
            // Проверка по алгоритму со слайда
            if (dotProduct < 0) {
                // Перпендикуляр не падает на луч - расстояние до начала луча
                return Math.sqrt(P1M_x * P1M_x + P1M_y * P1M_y);
            } else {
                // Перпендикуляр падает на луч
                // Длина вектора P1P2 в квадрате
                const P1P2_length_sq = P1P2_x * P1P2_x + P1P2_y * P1P2_y;
                
                // Параметр проекции
                const t = dotProduct / P1P2_length_sq;
                
                // Точка проекции
                const proj_x = P1.x + t * P1P2_x;
                const proj_y = P1.y + t * P1P2_y;
                
                // Расстояние от M до точки проекции
                const dx = M.x - proj_x;
                const dy = M.y - proj_y;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }
        
        function create2DDistanceVisualization(scene) {
            // Точки как на слайде (все Z = 0)
            const P1 = new BABYLON.Vector3(-3, 0, 0);  // Начало луча
            const P2 = new BABYLON.Vector3(3, 0, 0);   // Направление луча
            const M = new BABYLON.Vector3(1, 2, 0);    // Точка M
            
            // Вычисляем расстояние
            const distance = distanceToRay2D(M, P1, P2);
            document.getElementById('distanceValue').textContent = distance.toFixed(2);
            
            // Визуализация в 2D
            
            // 1. Луч (красная линия от P1 через P2)
            const rayPoints = [
                P1,
                P2,
                new BABYLON.Vector3(5, 0, 0) // Продолжение луча
            ];
            const rayLine = BABYLON.MeshBuilder.CreateLines("ray", { points: rayPoints }, scene);
            rayLine.color = new BABYLON.Color3(1, 0, 0);
            
            // 2. Точка M (зеленая)
            const pointM = BABYLON.MeshBuilder.CreateSphere("pointM", { diameter: 0.2 }, scene);
            pointM.position = M;
            const greenMat = new BABYLON.StandardMaterial("greenMat", scene);
            greenMat.diffuseColor = new BABYLON.Color3(0, 1, 0);
            pointM.material = greenMat;
            
            // 3. Начало луча P1 (синяя)
            const pointP1 = BABYLON.MeshBuilder.CreateSphere("pointP1", { diameter: 0.2 }, scene);
            pointP1.position = P1;
            const blueMat = new BABYLON.StandardMaterial("blueMat", scene);
            blueMat.diffuseColor = new BABYLON.Color3(0, 0, 1);
            pointP1.material = blueMat;
            
            // 4. Точка P2 (синяя)
            const pointP2 = BABYLON.MeshBuilder.CreateSphere("pointP2", { diameter: 0.2 }, scene);
            pointP2.position = P2;
            pointP2.material = blueMat;
            
            // 5. Вычисляем ближайшую точку на луче
            const P1P2_x = P2.x - P1.x;
            const P1P2_y = P2.y - P1.y;
            const P1M_x = M.x - P1.x;
            const P1M_y = M.y - P1.y;
            const dotProduct = P1M_x * P1P2_x + P1M_y * P1P2_y;
            
            let closestPoint;
            if (dotProduct < 0) {
                closestPoint = P1; // Перпендикуляр не падает на луч
            } else {
                const t = dotProduct / (P1P2_x * P1P2_x + P1P2_y * P1P2_y);
                closestPoint = new BABYLON.Vector3(
                    P1.x + t * P1P2_x,
                    P1.y + t * P1P2_y,
                    0
                );
            }
            
            // 6. Линия от M до ближайшей точки (желтая)
            const distanceLine = BABYLON.MeshBuilder.CreateLines("distanceLine", {
                points: [M, closestPoint]
            }, scene);
            distanceLine.color = new BABYLON.Color3(1, 1, 0);
            
            // 7. Ближайшая точка на луче (желтая)
            const closestPointMesh = BABYLON.MeshBuilder.CreateSphere("closest", { diameter: 0.15 }, scene);
            closestPointMesh.position = closestPoint;
            const yellowMat = new BABYLON.StandardMaterial("yellowMat", scene);
            yellowMat.diffuseColor = new BABYLON.Color3(1, 1, 0);
            closestPointMesh.material = yellowMat;
            
            // Подписи
            addText(scene, "M", M.x + 0.2, M.y + 0.2);
            addText(scene, "P₁", P1.x - 0.3, P1.y - 0.3);
            addText(scene, "P₂", P2.x + 0.2, P2.y - 0.3);
            addText(scene, "луч", 4, 0.3);
        }
        
        // Функция для добавления текста (упрощённо)
      
        
        window.addEventListener("resize", () => {
            engine.resize();
        });
    </script>
</body>
</html>

