<!DOCTYPE html>
<html>
<head>
    <title>2D –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ç–æ—á–∫–∏ –¥–æ –ª—É—á–∞</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 8px;
            min-width: 250px;
        }
        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(113, 108, 145, 0.95);
            padding: 20px;
            border-radius: 10px;
            border: 3px solid rgb(113, 108, 145);
            min-width: 300px;
            color: white;
        }
        .control-group {
            margin: 15px 0;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }
        .control-group h4 {
            margin: 0 0 10px 0;
            color: #fff;
        }
        .input-row {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }
        .input-row label {
            width: 30px;
            font-weight: bold;
            margin-right: 5px;
        }
        .input-row input {
            width: 60px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-right: 10px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }
        button:hover {
            background: #45a049;
        }
        .camera-control {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 20px;
            height: 20px;
            background: rgba(255, 0, 0, 0.5);
            border: 2px solid red;
            cursor: move;
        }
        .reset-camera {
            position: absolute;
            bottom: 50px;
            left: 20px;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    
    <div id="info">
        <h3>–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ç–æ—á–∫–∏ –¥–æ –ª—É—á–∞</h3>
        <p>–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: <span id="distanceValue">0</span></p>
        <p>–¢–æ—á–∫–∞ M: (<span id="pointMCoords">1, 2, 0</span>)</p>
        <p>–õ—É—á: P‚ÇÅ(<span id="pointP1Coords">-3, 0, 0</span>)</p>
        <p>–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: (<span id="directionCoords">6, 0, 0</span>)</p>
    </div>
    
    <div class="control-panel">
        <h3>üéØ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h3>
        
        <div class="control-group">
            <h4>üîµ –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ª—É—á–∞</h4>
            <div class="input-row">
                <label>P1 X:</label>
                <input type="number" id="p1_x" value="-3" step="0.1">
                <label>Y:</label>
                <input type="number" id="p1_y" value="0" step="0.1">
                <label>Z:</label>
                <input type="number" id="p1_z" value="0" step="0.1">
            </div>
            <div class="input-row">
                <label>–ù–∞–ø—Ä X:</label>
                <input type="number" id="dir_x" value="1" step="0.1">
                <label>Y:</label>
                <input type="number" id="dir_y" value="0" step="0.1">
                <label>Z:</label>
                <input type="number" id="dir_z" value="0" step="0.1">
            </div>
            <button onclick="updateRay()">–û–±–Ω–æ–≤–∏—Ç—å –ª—É—á</button>
        </div>
        
        <div class="control-group">
            <h4>üü¢ –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–æ—á–∫–∏ M</h4>
            <div class="input-row">
                <label>X:</label>
                <input type="number" id="m_x" value="1" step="0.1">
                <label>Y:</label>
                <input type="number" id="m_y" value="2" step="0.1">
                <label>Z:</label>
                <input type="number" id="m_z" value="0" step="0.1">
            </div>
            <button onclick="updatePointM()">–û–±–Ω–æ–≤–∏—Ç—å —Ç–æ—á–∫—É</button>
        </div>
        
        <div class="control-group">
            <h4>üìê –î–µ–π—Å—Ç–≤–∏—è</h4>
            <button onclick="dropPerpendicular()">–û–ø—É—Å—Ç–∏—Ç—å –ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä</button>
        </div>
    </div>

    <!-- –û–±–ª–∞—Å—Ç—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–∞–º–µ—Ä–æ–π -->
    <div class="camera-control" id="cameraControl"></div>
    <button class="reset-camera" onclick="resetCamera()">üîÑ –°–±—Ä–æ—Å –∫–∞–º–µ—Ä—ã</button>
    
    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let pointM, pointP1, pointP2;
        let pointMMesh, pointP1Mesh, pointP2Mesh, rayLine, distanceLine, closestPointMesh, directionCone;
        let isDragging = false;
        let draggedMesh = null;
        let camera;
        let isCameraDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let initialCameraPosition = new BABYLON.Vector3(0, 0, 15);
        let initialCameraRotation = new BABYLON.Vector3(-Math.PI / 2, Math.PI / 2, 0);

        function createScene() {
            const scene = new BABYLON.Scene(engine);
            
            // –ö–∞–º–µ—Ä–∞ –¥–ª—è 2D –≤–∏–¥–∞
            camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2, 15, 
                new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);
            camera.inputs.attached.pointers.angularSensibility = 100000;
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é –∫–∞–º–µ—Ä—ã
            initialCameraPosition = camera.position.clone();
            initialCameraRotation = new BABYLON.Vector3(
                camera.alpha, camera.beta, camera.radius
            );
            
            // –°–≤–µ—Ç
            new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 0, -1), scene);
            
            // –°–æ–∑–¥–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ —Ç–æ—á–∫–∏
            pointP1 = new BABYLON.Vector3(-3, 0, 0);
            pointP2 = new BABYLON.Vector3(3, 0, 0); // P2 –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –∏–∑ P1 + –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
            pointM = new BABYLON.Vector3(1, 2, 0);
            
            // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä–æ–π
            setupCameraControl();
            
            // –°–æ–∑–¥–∞–µ–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é
            createVisualization(scene);
            
            // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ —Ç–æ—á–µ–∫
            setupDragAndDrop(scene, camera);
            
            return scene;
        }
        
        function setupCameraControl() {
            const cameraControl = document.getElementById('cameraControl');
            
            cameraControl.addEventListener('mousedown', function(e) {
                isCameraDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (isCameraDragging) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;
                    
                    // –î–≤–∏–≥–∞–µ–º –∫–∞–º–µ—Ä—É
                    camera.alpha -= deltaX * 0.01;
                    camera.beta -= deltaY * 0.01;
                    
                    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —É–≥–æ–ª beta —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–≤–æ—Ä–∞—á–∏–≤–∞—Ç—å –∫–∞–º–µ—Ä—É
                    camera.beta = Math.max(0.1, Math.min(Math.PI - 0.1, camera.beta));
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });
            
            document.addEventListener('mouseup', function() {
                isCameraDragging = false;
            });
        }
        
        function resetCamera() {
            camera.alpha = initialCameraRotation.x;
            camera.beta = initialCameraRotation.y;
            camera.radius = initialCameraRotation.z;
            camera.position = initialCameraPosition.clone();
        }
        
        function updateRay() {
            const p1_x = parseFloat(document.getElementById('p1_x').value);
            const p1_y = parseFloat(document.getElementById('p1_y').value);
            const p1_z = parseFloat(document.getElementById('p1_z').value);
            const dir_x = parseFloat(document.getElementById('dir_x').value);
            const dir_y = parseFloat(document.getElementById('dir_y').value);
            const dir_z = parseFloat(document.getElementById('dir_z').value);
            
            pointP1 = new BABYLON.Vector3(p1_x, p1_y, p1_z);
            // P2 = P1 + –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ * 6 (–¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏)
            pointP2 = new BABYLON.Vector3(
                p1_x + dir_x * 6,
                p1_y + dir_y * 6, 
                p1_z + dir_z * 6
            );
            
            createVisualization(scene);
            updateInfoPanel();
        }
        
        function updatePointM() {
            const m_x = parseFloat(document.getElementById('m_x').value);
            const m_y = parseFloat(document.getElementById('m_y').value);
            const m_z = parseFloat(document.getElementById('m_z').value);
            
            pointM = new BABYLON.Vector3(m_x, m_y, m_z);
            createVisualization(scene);
            updateInfoPanel();
        }
        
        function dropPerpendicular() {
            // –ù–∞—Ö–æ–¥–∏–º –±–ª–∏–∂–∞–π—à—É—é —Ç–æ—á–∫—É –Ω–∞ –ª—É—á–µ
            const closestPoint = findClosestPointOnRay(pointM, pointP1, pointP2);
            
            // –ü–µ—Ä–µ–º–µ—â–∞–µ–º —Ç–æ—á–∫—É M –∫ –æ—Å–Ω–æ–≤–∞–Ω–∏—é –ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä–∞
            pointM.copyFrom(closestPoint);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª–µ –≤–≤–æ–¥–∞
            document.getElementById('m_x').value = pointM.x.toFixed(1);
            document.getElementById('m_y').value = pointM.y.toFixed(1);
            document.getElementById('m_z').value = pointM.z.toFixed(1);
            
            createVisualization(scene);
            updateInfoPanel();
        }
        
        function updateInfoPanel() {
            document.getElementById('pointMCoords').textContent = 
                `${pointM.x.toFixed(1)}, ${pointM.y.toFixed(1)}, ${pointM.z.toFixed(1)}`;
            document.getElementById('pointP1Coords').textContent = 
                `${pointP1.x.toFixed(1)}, ${pointP1.y.toFixed(1)}, ${pointP1.z.toFixed(1)}`;
            
            const direction = pointP2.subtract(pointP1);
            document.getElementById('directionCoords').textContent = 
                `${direction.x.toFixed(1)}, ${direction.y.toFixed(1)}, ${direction.z.toFixed(1)}`;
        }
        
        function createVisualization(scene) {
            // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –æ–±—ä–µ–∫—Ç—ã –µ—Å–ª–∏ –µ—Å—Ç—å
            if (rayLine) rayLine.dispose();
            if (distanceLine) distanceLine.dispose();
            if (closestPointMesh) closestPointMesh.dispose();
            if (directionCone) directionCone.dispose();
            
            // –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
            const distance = distanceToRay2D(pointM, pointP1, pointP2);
            document.getElementById('distanceValue').textContent = distance.toFixed(2);
            
            // –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Ç–æ—á–∫—É M (–∑–µ–ª–µ–Ω–∞—è)
            if (!pointMMesh) {
                pointMMesh = BABYLON.MeshBuilder.CreateSphere("pointM", { diameter: 0.3 }, scene);
                const greenMat = new BABYLON.StandardMaterial("greenMat", scene);
                greenMat.diffuseColor = new BABYLON.Color3(0, 1, 0);
                pointMMesh.material = greenMat;
            }
            pointMMesh.position = pointM.clone();
            
            // –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Ç–æ—á–∫—É P1 (—Å–∏–Ω—è—è)
            if (!pointP1Mesh) {
                pointP1Mesh = BABYLON.MeshBuilder.CreateSphere("pointP1", { diameter: 0.3 }, scene);
                const blueMat = new BABYLON.StandardMaterial("blueMat", scene);
                blueMat.diffuseColor = new BABYLON.Color3(0, 0, 1);
                pointP1Mesh.material = blueMat;
            }
            pointP1Mesh.position = pointP1.clone();
            
            // –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Ç–æ—á–∫—É P2 (—Å–∏–Ω—è—è)
            if (!pointP2Mesh) {
                pointP2Mesh = BABYLON.MeshBuilder.CreateSphere("pointP2", { diameter: 0.3 }, scene);
                pointP2Mesh.material = pointP1Mesh.material;
            }
            pointP2Mesh.position = pointP2.clone();
            
            // –°–æ–∑–¥–∞–µ–º –ª—É—á (–∫—Ä–∞—Å–Ω–∞—è –ª–∏–Ω–∏—è –æ—Ç P1 —á–µ—Ä–µ–∑ P2)
            const rayPoints = [
                pointP1,
                pointP2,
                new BABYLON.Vector3(
                    pointP1.x + (pointP2.x - pointP1.x) * 2,
                    pointP1.y + (pointP2.y - pointP1.y) * 2,
                    pointP1.z + (pointP2.z - pointP1.z) * 2
                )
            ];
            rayLine = BABYLON.MeshBuilder.CreateLines("ray", { points: rayPoints }, scene);
            rayLine.color = new BABYLON.Color3(1, 0, 0);
            
            // –í—ã—á–∏—Å–ª—è–µ–º –±–ª–∏–∂–∞–π—à—É—é —Ç–æ—á–∫—É –Ω–∞ –ª—É—á–µ
            const closestPoint = findClosestPointOnRay(pointM, pointP1, pointP2);
            
            // –õ–∏–Ω–∏—è —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è (–∂–µ–ª—Ç–∞—è)
            distanceLine = BABYLON.MeshBuilder.CreateLines("distanceLine", {
                points: [pointM, closestPoint]
            }, scene);
            distanceLine.color = new BABYLON.Color3(1, 1, 0);
            
            // –ë–ª–∏–∂–∞–π—à–∞—è —Ç–æ—á–∫–∞ (–∂–µ–ª—Ç–∞—è)
            closestPointMesh = BABYLON.MeshBuilder.CreateSphere("closest", { diameter: 0.2 }, scene);
            closestPointMesh.position = closestPoint;
            const yellowMat = new BABYLON.StandardMaterial("yellowMat", scene);
            yellowMat.diffuseColor = new BABYLON.Color3(1, 1, 0);
            closestPointMesh.material = yellowMat;
            
            // –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—É—Å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            createDirectionCone(scene);
        }
        
        function createDirectionCone(scene) {
            directionCone = BABYLON.MeshBuilder.CreateCylinder("directionCone", {
                height: 0.8,
                diameterTop: 0,
                diameterBottom: 0.5,
                tessellation: 7
            }, scene);
            
            const direction = pointP2.subtract(pointP1).normalize();
            const coneOffset = 0.5;
            
            directionCone.position = new BABYLON.Vector3(
                pointP2.x + direction.x * coneOffset,
                pointP2.y + direction.y * coneOffset,
                pointP2.z + direction.z * coneOffset
            );
            
            // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–≤–æ—Ä–æ—Ç –¥–ª—è 3D
            const angle = Math.atan2(direction.y, direction.x);
            directionCone.rotation.y = angle + Math.PI / 2;
            
            const purpleMat = new BABYLON.StandardMaterial("purpleMat", scene);
            purpleMat.diffuseColor = new BABYLON.Color3(0.5, 0, 0.5);
            directionCone.material = purpleMat;
        }
        
        function setupDragAndDrop(scene, camera) {
            scene.onPointerDown = function(evt, pickResult) {
                if (pickResult.hit) {
                    const mesh = pickResult.pickedMesh;
                    if (mesh === pointMMesh || mesh === pointP1Mesh || mesh === pointP2Mesh) {
                        isDragging = true;
                        draggedMesh = mesh;
                    }
                }
            };
            
            scene.onPointerMove = function(evt) {
                if (isDragging && draggedMesh) {
                    const pickResult = scene.pick(scene.pointerX, scene.pointerY);
                    if (pickResult.hit) {
                        const newPosition = pickResult.pickedPoint;
                        
                        if (draggedMesh === pointMMesh) {
                            pointM.copyFrom(newPosition);
                            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª—è –≤–≤–æ–¥–∞
                            document.getElementById('m_x').value = pointM.x.toFixed(1);
                            document.getElementById('m_y').value = pointM.y.toFixed(1);
                            document.getElementById('m_z').value = pointM.z.toFixed(1);
                        } else if (draggedMesh === pointP1Mesh) {
                            pointP1.copyFrom(newPosition);
                            document.getElementById('p1_x').value = pointP1.x.toFixed(1);
                            document.getElementById('p1_y').value = pointP1.y.toFixed(1);
                            document.getElementById('p1_z').value = pointP1.z.toFixed(1);
                        } else if (draggedMesh === pointP2Mesh) {
                            pointP2.copyFrom(newPosition);
                            // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                            const direction = pointP2.subtract(pointP1).normalize();
                            document.getElementById('dir_x').value = direction.x.toFixed(1);
                            document.getElementById('dir_y').value = direction.y.toFixed(1);
                            document.getElementById('dir_z').value = direction.z.toFixed(1);
                        }
                        
                        createVisualization(scene);
                        updateInfoPanel();
                    }
                }
            };
            
            scene.onPointerUp = function() {
                isDragging = false;
                draggedMesh = null;
            };
        }
        
        // 2D –∞–ª–≥–æ—Ä–∏—Ç–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –æ—Ç —Ç–æ—á–∫–∏ –¥–æ –ª—É—á–∞ (—Ä–∞–±–æ—Ç–∞–µ—Ç –∏ –≤ 3D)
        function distanceToRay2D(M, P1, P2) {
            const P1P2 = P2.subtract(P1);
            const P1M = M.subtract(P1);
            
            const dotProduct = BABYLON.Vector3.Dot(P1M, P1P2);
            
            if (dotProduct < 0) {
                return BABYLON.Vector3.Distance(M, P1);
            } else {
                const P1P2_length_sq = P1P2.lengthSquared();
                const t = dotProduct / P1P2_length_sq;
                
                const projection = P1.add(P1P2.scale(t));
                return BABYLON.Vector3.Distance(M, projection);
            }
        }
        
        function findClosestPointOnRay(M, P1, P2) {
            const P1P2 = P2.subtract(P1);
            const P1M = M.subtract(P1);
            
            const dotProduct = BABYLON.Vector3.Dot(P1M, P1P2);
            
            if (dotProduct < 0) {
                return P1.clone();
            } else {
                const t = dotProduct / P1P2.lengthSquared();
                return P1.add(P1P2.scale(t));
            }
        }
        
        const scene = createScene();
        
        engine.runRenderLoop(() => {
            scene.render();
        });
        
        window.addEventListener("resize", () => {
            engine.resize();
        });
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–ª–µ–π –≤–≤–æ–¥–∞
        updateInfoPanel();
    </script>
</body>
</html>
